title: c++ Templates第二章函数模板
tags:
  - c++
  - 模板
  - 读书笔记
id: 5
categories:
  - c++
date: 2014-04-27 09:58:02
---

函数模板是那些被参数化的函数，它提供了一种函数的行为，该函数行为可以用多种不同的类型进行调用，它与普通函数的唯一区别是有些函数元素是未确定的。模板参数必须用如下形式的语法进行声明
template&lt;用逗号隔开的参数列表&gt;，例如：
templae&lt;typename T&gt;
inline T const &amp; max(T const&amp; a ,T const &amp; b)
{
return a&lt;b?b:a;
}
参数类型T表示的是调用者调用这个函数时所指定的任意类型，可以使用任何类型来实例化这个参数，唯一的要求是：所使用的类型必须提供模板使用的操作，如果在上边的函数中的&lt;函数。<!--more-->

从语义上将，typename可以用class 代替，并且两者是等价的，class T也可以用任何类型进行实例化，并不只是类类型。

在使用的时候，并不是把模板编译成一个可以处理任何类型的单一实体；而是对于实例化模板参数的每种类型都从模板产生出一个不同的实体，这种针对具体类型代替模板参数的过程叫做实例化（instantiation）,它产生了模板的一个实例。
如果试图基于一个不支持模板内部所使用操作的类型实例化一个模板，那么将会导致一个编译器错误。因此从这里可以看到模板被编译了两次：
（1）实例化之前，先检查模板代码本身，查看语法错误是否正确，在这里会发现错误的语法如遗漏分号等。
（2）在实例化期间，检查模板代码，查看是否所有的调用都有效，在这里会发现无效的调用，如该实例化类型不支持某些函数调用等。
当为某些实参调用一个诸如max()的模板时，模板参数可以由我们所传递的实参来决定，这里不允许进行自动类型转换，每个T都必须正确的匹配。
如果两个参数类型不同可以使用以下方式进行处理：
（1）对实参进行强制类型转换，使得它们能够互相匹配max(static_cast&lt;double&gt;(4),4.2)

（2）显式指定（或者限定）T的类型：max&lt;double&gt;(4,4.2);
（3）指定两个参数可以具有不同的类型。
调用参数的类型来构造子模板参数，所以模板参数和调用参数通常是相关的，这个概念称为：函数模板的实参演绎。当模板参数和调用参数没有发生关联，或者不能由调用惨呼来决定模板参数的时候，在调用时就必须显式指定模板实参。
模板实参演绎不适合返回类型，函数调用不能演绎出返回值得类型参数，必须显式的指定模板实参列表。
模板参数的演绎过程还可以指定第一个实参，让演绎过程推导其余的实参
函数模板也可以被重载，即相同的函数名称可以具有不同的函数定义。一个非模板函数可以和一个同名的函数模板同时存在，而且该函数模板还可以被实例化为这个非模板函数。对于非模板函数和同名的函数模板，如果其他条件都是相同的话，那么在调用的时候，重载解析过程通常会调用非模板函数，而不会从该模板产生出一个实例。当然也可以显示地指定一个空的模板实参列表，这样的语法告诉编译器：只有模板才能匹配这个调用，而所有的模板参数都应该嗲用实参演绎出来。
一般来说在重载函数的模板的时候，最好知识改变那些需要改变的内容，就是说应该把改变限制在以下两种情况：改变参数的数目或者显示地指定模板参数，否则会出现非预期的结果。
函数的所有重载版本的声明都应该位于该函数被调用的位置之前。

**小结：**
模板函数为不同的模板实参定义了一个函数家族
当你传递模板实参的时候，可以根据实参的类型来对函数模板进行实例化
你可以显示指定模板参数
你可以重载函数模板
当重载函数模板的时候，把改变限制在：显式的指定模板参数
一定要让函数模板的所有重载版本的生命都位于它们被调用的位置之前。