title: 深入浅出设计模式读书笔记
tags:
  - 设计模式
  - 读书笔记
id: 98
categories:
  - 学习笔记
date: 2015-05-08 15:00:07
---

<div>使用模式的最好的方式是："把模式装进脑子里然后在你的设计和已有的应用中寻找何处可以使用它们把会变化的部分取出并封装起来以便以后可以轻易地改动或扩充此部分而不影响不需要变化的其他部分</div>
<div>为了要把这两个行为从Duck类中分开我们将把它们从Duck类中取出来建立一组新类来代表每个行为。这次鸭子类不会负责实现Flying与Quacking接口反而是由我们制造的一组其他类专门实现FlyBehavior与QuackBehavior这就称为行为类由行为类而不是duck类来实现行为接口<!--more--></div>
<div></div>
<div>策略模式定义算法族分别封装起来让他们之间可以相互替换,此模式让算法的变化独立于使用算法的客户.</div>
<div>观察者模式定义了对象之间的一对多依赖这样一来当一个对象改变状态时它的所有依赖这都会收到通知并自动更新。观察者模式提供了一种对象设计让主题和观察者之间松耦合,SWing大量使用观察者模式许多GUI框架也是如此.JButton的超类AbstractButton,有许多增加与删除倾听者(listener)的方法这些方法可以让观察者感应到Swing组件的不同类型事件.</div>
<div></div>
<div>利用继承设计子类的行为，是在编译时静态决定的，而且所有的子类都会继承到相同的行为，然而如果能够利用组合的做法扩展对象的行为，就可以在运行时动态的进行扩展。</div>
<div></div>
<div>设计原则：类应该对扩展开放，对修改关闭</div>
<div>装饰者模式动态的将责任附加到对象上，若要扩展功能，装饰者提供了比继承更有弹性的替代方案。</div>
<div>工厂方法用来处理对象的创建，并将这样的行为封装在子类中，这样，客户程序中关于超累的代码就和子类对象创建代码解耦了。</div>
<div>所有工厂模式都用来封装对象的创建，工厂方法模式通过让子类决定该创建的对象是什么，来达到将对象创建的过程封装的目的。</div>
<div>工厂方法模式定义了一个创建对象的接口，但由子类决定要实例化的类是哪个。工厂方法让类把实例化推迟到子类。工厂方法让子类决定要实例化的类是哪个，所谓的决定不是值模式允许子类本身在运行时做决定，而是指在编写创建者类时，不需要知道实例创建的产品是哪个，选择使用哪个子类，自然就决定了实际创建的产品是什么。</div>
<div>抽象工厂模式定义了一个接口，用于创建相关或依赖对象的家族，而不需要明确制定具体类，抽象工厂允许客户使用抽象的接口来创建一组相关的产品，而不需要知道实际产出的具体产品是什么，这样依赖，客户就从具体的产品中被解耦。抽象工厂的方法经常以工厂方法的方式实现，抽象工厂的任务是定义一个负责创建一组产品的几口，这个接口内的每个方法都负责创建一个具体产品，同时我们利用实现抽象工厂的子类来提提供这些具体的做法，所以在抽象工厂中利用工厂方法实现生产方法是相当自然的做法。</div>
<div>单件模式确保一个类只有一个实例，并提供一个全局访问点。单件模式在多线程的情况下会遇到各种问题，一下是三种解决方案：1.如果getInstance()的性能对应用程序不是很关键，就什么都别做；2.使用“急切”创建实例，而不是延迟实例化的方法；3.用“双重检查加锁”，在getInstance()中减少使用同步。</div>
<div></div>
<div>命令模式将请求封装成对象，以便使用不同的请求队列或日志来参数化其他对象，命令模式也支持可撤销的操作</div>
<div>适配器模式将一个类的接口，转换成客户期望的另一个接口，适配器让原本接口不兼容的类可以合作无间。</div>
<div></div>
<div>外观模式提供了一个统一的接口，用来访问子系统中的一群接口，外观定义了一个高层接口，让子系统更容易使用。</div>
<div>有了外观模式，通过实现一个提供更合理的接口的外观类，你可以将一个复杂的子系统变得容易使用，如果你需要复杂系统的强大威力，别担心，还是可以使用原来的复杂接口的，但是如果你需要的是一个方便使用的接口，那就使用外观；适配器模式将一个或多个类接口编程客户所期望的一个接口，虽然大多数教科书上锁采用的例子中适配器只适配一个类，但是你可以适配许多类来提供一个接口让客户编码，类似的一个外观也可以只针对一个拥有复杂接口的类提供简化的接口。两种模式的差异，不在于他们包装了几个类，而是在于它们的意图。适配器模式的意图是，改变接口符合客户期望；而外观模式的意图是提供子系统的一个简化接口。</div>
<div></div>
<div>模板方法模式在一个方法中定义了一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中的某些步骤。这个模式是用来创建一个算法的模板，模板就是一个方法，这个方法将算法定义成一组步骤，其中的任何步骤都可以是抽象的，由子类负责实现，这可以确保算法结构保持不变，同时由子类提供部分实现。</div>
<div>迭代器模式提供一种方法顺序访问一个聚合对象中的各个元素，而不暴露其内部的表示。迭代器模式让我们能够游走于聚合内的每一个元素，而不暴露其内部的表示，把游走的任务放在迭代器上，而不是聚合上，这样简化了聚合的接口和实现，也让责任各得其所。</div>
<div></div>
<div>状态模式允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类。这个模式将状态封装成独立的类，并将动作委托到代表当前状态的对象，行为会随着内部状态的改变而改变</div>
<div></div>
<div>代理模式为另一个对象提供一个替身或占位符以控制对这个对象的访问，使用代理模式创建代表对象，让代表对象控制某对象的访问，被代理的对象可以是远程的对象，创建开销大的对象或需要安全控制的对象</div>
<div></div>
<div>
<table cellspacing="0" cellpadding="0">
<tbody>
<tr>
<td>模式</td>
<td>例子</td>
</tr>
<tr>
<td>策略模式</td>
<td>Duck</td>
</tr>
<tr>
<td>观察者模式</td>
<td>天气数据的显示，Swing Listener</td>
</tr>
<tr>
<td>装饰者模式</td>
<td>奶茶制作（包含各种佐料）,Java I/O类体系</td>
</tr>
<tr>
<td>工厂方法</td>
<td>披萨制作</td>
</tr>
<tr>
<td colspan="1">抽象工厂</td>
<td colspan="1">各地区披萨原料厂的设计</td>
</tr>
<tr>
<td colspan="1">单件模式</td>
<td colspan="1"></td>
</tr>
<tr>
<td colspan="1">命令模式</td>
<td colspan="1">遥控器</td>
</tr>
<tr>
<td colspan="1">适配器模式</td>
<td colspan="1"></td>
</tr>
<tr>
<td colspan="1">外观模式</td>
<td colspan="1">电影院系统</td>
</tr>
<tr>
<td colspan="1">模板方法</td>
<td colspan="1">冲咖啡，茶；排序算法；各种框架</td>
</tr>
<tr>
<td colspan="1">迭代器模式</td>
<td colspan="1"></td>
</tr>
<tr>
<td colspan="1">状态模式</td>
<td colspan="1">糖果机</td>
</tr>
<tr>
<td colspan="1">代理模式</td>
<td colspan="1">远程调用</td>
</tr>
</tbody>
</table>
</div>